
## 섹션 2. 제네릭 - Generic1

### 제네릭이란?

- 제네릭(Generic)을 사용하면 **코드 재사용**과 **타입 안전성**을 동시에 확보할 수 있음
- `< >`를 사용해 선언한 클래스를 **제네릭 클래스**라고 함
- 제네릭 클래스를 사용하면 `Integer`, `String` 등 구체적인 타입을 미리 지정하지 않아도 됨
- 클래스명 오른쪽에 `<T>`를 선언하면, `T`는 **타입 매개변수(type parameter)**가 됨
- 클래스 내부에서 `T value`와 같이 타입 매개변수를 사용하면, 실제 객체 생성 시 구체적인 타입으로 대체됨

- 제네릭을 사용하면, 클래스 내부에서 사용할 타입을 **정의 시점이 아닌 생성 시점**에 결정 가능

### 메서드 매개변수 vs 제네릭 타입 매개변수

| 구분 | 설명 |
|------|------|
| 메서드 매개변수 | 사용할 **값**에 대한 결정을 나중으로 미룸 |
| 제네릭 타입 매개변수 | 사용할 **타입**에 대한 결정을 나중으로 미룸 |

- 메서드는 **매개변수에 인자**를 전달해 값을 결정
- 제네릭 클래스는 **타입 매개변수에 타입 인자**를 전달해 사용할 타입을 결정

- 제네릭 용어와 관례도 학습함 (예: `T`, `E`, `K`, `V` 등의 관용적 타입 명칭)

---

## 섹션 3. 제네릭 - Generic2


### 타입 제한의 필요성

- 제네릭은 기본적으로 어떤 타입이든 허용함
- 타입 매개변수를 `Object`로 가정하고 사용할 경우, Object의 기능만 사용 가능

- 이 문제를 해결하기 위해 **상위 타입 제한**을 적용


### 타입 제한 적용

- `T extends Number`처럼 상한을 설정해 특정 타입군만 사용 가능
- 이렇게 하면, **타입 안정성**을 유지하면서도 **상위 타입의 기능**을 사용할 수 있음

- 코드 재사용성과 타입 안정성 모두 확보 가능

---


### 제네릭 메서드와 제네릭 클래스의 차이

- 제네릭 타입: 객체 **생성 시점**에 타입 인자 전달
- 제네릭 메서드: 메서드 **호출 시점**에 타입 인자 전달
- 제네릭 메서드는 클래스 전체가 아닌 **특정 메서드 단위**에만 제네릭 적용할 때 사용

| 구분 | 설명 |
|------|------|
| 정적(static) 메서드 | 제네릭 **메서드만** 적용 가능 |
| 인스턴스 메서드 | 제네릭 **타입, 메서드 모두** 적용 가능 |
| 우선순위 | 제네릭 메서드가 제네릭 타입보다 **우선 적용**됨 |

---

### 와일드카드 (`?`)

- `?`는 하나 이상의 타입을 포괄하는 **특수 문자**
- **제네릭 타입 또는 메서드를 선언할 때가 아니라**, 이미 정의된 제네릭을 활용할 때 사용
- 예를 들어, `List<?>`는 어떤 타입의 리스트든 받을 수 있음

#### 상한 와일드카드

- `? extends Type`: 특정 타입(Type) **하위 타입만 허용**

### 와일드카드 vs 제네릭 타입/메서드

- 와일드카드는 제네릭 타입 활용에 적합
- **타입이 꼭 필요하고, 메서드 내부에서 타입이 바뀌어야 한다면** 제네릭 타입 또는 제네릭 메서드를 사용하는 것이 적절

---

### 타입 이레이저 (Type Erasure)

- 제네릭은 **컴파일 시점**에만 존재
- 컴파일 이후에는 **타입 정보가 삭제됨**
- 런타임 시에는 모든 제네릭 타입이 **Object**로 처리됨

---


## 섹션 4. 컬렉션 프레임워크 - ArrayList

### 배열의 특징 1 - 배열과 인덱스

자료구조는 데이터를 구조화해서 다루는 방식이고 배열은 그 대표적인 예시

배열의 특징
- 인덱스를 통해 데이터 접근이 매우 빠름
- 입력, 변경, 조회는 인덱스를 이용해서 한 번의 계산으로 위치를 바로 찾을 수 있음
- 하지만 검색은 모든 요소를 하나씩 확인해야 해서 오래 걸림

### 빅오(Big-O) 표기법

알고리즘 성능을 수학적으로 표현한 방식임. 대표적인 시간 복잡도

| 표기법      | 의미                       | 설명                                              |
|-------------|----------------------------|---------------------------------------------------|
| O(1)        | 상수 시간                  | 입력 크기에 관계없이 실행 시간 일정               |
| O(n)        | 선형 시간                  | 입력 크기에 비례해 실행 시간 증가                 |
| O(n²)       | 제곱 시간                  | 입력 크기의 제곱에 비례해 실행 시간 증가          |
| O(log n)    | 로그 시간                  | 입력 크기의 로그에 비례해 실행 시간 증가          |
| O(n log n)  | 선형 로그 시간             | 대표적으로 병합 정렬에서 사용됨                   |

**배열 관련 시간 복잡도 정리**

| 작업            | 시간 복잡도 |
|-----------------|--------------|
| 인덱스 접근     | O(1)         |
| 순차 검색       | O(n)         |

### 배열의 특징 2 - 데이터 추가 시 성능 변화

배열에 데이터를 추가할 때 위치에 따라 성능이 달라짐

| 위치     | 설명                                                                 | 시간 복잡도 |
|----------|----------------------------------------------------------------------|--------------|
| 첫번째   | 첫 인덱스 접근 O(1) + 나머지 한 칸씩 밀기 O(n)                       | O(n)         |
| 중간     | 중간 인덱스 접근 O(1) + 오른쪽 데이터 평균 O(n/2) 밀기              | O(n)         |
| 마지막   | 이동 없이 바로 추가 가능                                             | O(1)         |

배열의 한계 
→ 크기를 고정해야 해서 유연하지 않음

### 직접 구현하는 배열 리스트 1 - 시작

기존 배열의 불편함

1. 길이 조절 불가
2. 데이터 추가가 번거로움

이런 문제를 해결하기 위해 **동적으로 크기를 조절할 수 있는 List 자료 구조**가 사용됨

**List**란: 순서가 있고, 중복 데이터를 허용하는 자료 구조임

### 직접 구현하는 배열 리스트 2~5 - 동적 배열 및 제네릭

제네릭으로 구현할 때 `Object[] elementData`를 그대로 사용하는 이유

- 제네릭은 런타임에 타입 정보가 사라짐(타입 소거), 그래서 생성자에서는 타입 매개변수를 사용할 수 없음
- 그래서 생성자 내부에서 배열을 만들 땐 `Object[]`를 써야 함
- 하지만 입력/반환은 제네릭 타입으로 제한되기 때문에 다운캐스팅 과정이 안전하게 보장됨

**MyArrayList 단점 요약**

- 정확한 크기를 예측하지 못하면 메모리를 낭비하게 됨
- 중간 삽입/삭제 시 성능이 떨어짐

정리  
→ 배열 리스트는 **마지막에 추가/삭제할 때는 효율적**이지만, **앞이나 중간 위치에서는 성능이 좋지 않음**

---

## 섹션 5. 컬렉션 프레임워크 - LinkedList

### 배열 리스트의 단점

배열 리스트는 내부에 **배열**을 사용해서 데이터를 저장하고 관리함  
문제는 배열 크기를 미리 확보해야 해서, 얼마나 데이터가 추가될지 모르는 경우 **남는 공간이 낭비**된다는 것

### 노드와 연결

배열의 단점을 보완하기 위해 **노드(Node)** 를 사용해서 데이터를 연결하는 방식이 나옴

- 낭비되는 메모리 없이 필요한 만큼만 메모리를 확보해서 사용함
- 앞이나 중간에 데이터를 추가, 삭제할 때 효율적임
- 새로운 노드를 만들고, 서로 연결해서 관리함

**노드 클래스 구조**

```java
public class Node {
    Object item;
    Node next;
}
```

- `item`: 저장할 데이터
- `next`: 다음 노드를 가리키는 참조

이런 구조를 기반으로 데이터를 연결하는 자료구조를 **연결 리스트(LinkedList)** 라고 부름

---

### 연결 리스트 vs 배열 리스트 성능 비교

중간에 있는 항목을 추가하거나 삭제할 때, 연결 리스트와 배열 리스트 모두 시간 복잡도는 O(n)임  
하지만 상황에 따라 둘 중 더 나은 선택이 있음.

| 기능         | 배열 리스트 (ArrayList) | 연결 리스트 (LinkedList) |
|--------------|--------------------------|---------------------|
| 인덱스 조회   | O(1) (빠름)               | O(n) (느림)           |
| 검색         | O(n)                      | O(n)                |
| 앞에 추가    | O(n) (모두 이동해야 함)    | O(1) (노드만 연결)       |
| 뒤에 추가    | O(1)                      | O(n)                |
| 평균 위치 추가 | O(n)                    | O(n)                |

정리하면:

- **조회가 많고, 뒤쪽에 데이터 추가가 많을 때** → 배열 리스트가 성능이 더 좋음
- **앞쪽 데이터 추가/삭제가 많을 때** → 연결 리스트가 성능이 더 좋음

---

### 제네릭 도입

연결 리스트에 제네릭을 적용해서 타입을 고정할 수 있게 했음  
덕분에 여러 타입의 데이터를 안전하게 다룰 수 있음

---


## 섹션 6. 컬렉션 프레임워크 - List

### List 자료구조

- 순서가 있고, 중복을 허용하는 자료구조임

---

### 컴파일 타임 vs 런타임 의존관계

의존관계는 **컴파일 타임 의존관계**와 **런타임 의존관계**로 나뉨

| 구분            | 설명 |
|----------------|-----|
| 컴파일 타임 의존관계 | 코드 컴파일 시점에 자바 컴파일러가 보는 의존관계. 소스 코드에 정적으로 나타남.<br>ex) `BatchProcessor`는 `MyList` 인터페이스에만 의존 |
| 런타임 의존관계    | 프로그램 실행 시점에 생성된 인스턴스 간에 실제로 나타나는 의존관계. 실행 중 변할 수도 있음 |

- 생성자를 통해 런타임 의존관계를 주입하는 것을 **생성자 의존관계 주입** 또는 **생성자 주입**이라고 부름
- 클라이언트 클래스는 **컴파일 타임**에는 추상적인 것에 의존하고, **런타임**에는 구체적인 구현체를 주입받아서 사용함

**전략 패턴**
- 알고리즘을 클라이언트 코드 변경 없이 쉽게 교체할 수 있게 해주는 패턴임

---

### 직접 구현한 리스트 성능 비교

**시간 복잡도** 외에도 실제 성능은 여러 요소에 따라 달라짐.

- 요소들의 순차적 접근 속도
- 메모리 할당 및 해제 비용
- CPU 캐시 활용도 등

**ArrayList**

- 요소들이 메모리상에 연속적으로 존재함
- CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠름
- CAPACITY를 넘으면 배열을 복사해야 하지만, 한번에 2배씩 늘어나고 자주 발생하지 않아서 성능에 큰 영향 없음

**LinkedList**

- 각 요소가 별도의 객체로 존재하고, 다음 요소 참조를 가짐
- CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느림

**ArrayList vs LinkedList**

| 기준             | ArrayList | LinkedList |
|------------------|-----------|------------|
| 메모리 구조       | 연속된 배열 | 이중 연결 리스트 |
| 순차 접근 속도    | 빠름      | 느릴 수 있음 |
| 앞쪽 데이터 추가/삭제 | 느림 (O(n)) | 빠름 (O(1)) |
| 뒤쪽 데이터 추가   | 빠름 (O(1)) | 빠름 (O(1)) |
| 메모리 사용 효율  | 좋음      | 상대적으로 떨어짐 |

- 대부분의 경우 **ArrayList**가 성능상 유리함
- 앞쪽 데이터를 자주 추가하거나 삭제하는 경우라면 **LinkedList** 고려할 만함

---

### 자바 List 인터페이스

**List 자료 구조**

- 순서가 있고, 중복을 허용하는 컬렉션임

**Collection 인터페이스**

- 컬렉션 프레임워크의 핵심 인터페이스
- `List`, `Set`, `Queue` 같은 다양한 하위 인터페이스들과 함께 사용함

**List 인터페이스**

- 객체들의 순서가 있는 컬렉션
- 같은 객체를 중복 저장 가능
- 배열처럼 보이지만 크기가 동적으로 변할 수 있어 유연하게 사용 가능
- 주요 구현체: `ArrayList`, `LinkedList` 등

---

### ArrayList 특징

- 배열을 이용해서 데이터 관리
- 기본 `Capacity = 10`
    - Capacity를 넘어가면 **50%씩 증가**함
- **메모리 고속 복사 연산** 사용
    - 중간 위치에 데이터를 추가하면 이후 요소를 한 칸씩 이동시켜야 함
    - `System.arraycopy()` 같은 최적화된 복사 기능 덕분에 빠르게 수행됨

---

### LinkedList 특징

- 이중 연결 리스트 구조 사용
- 첫 번째 노드와 마지막 노드를 모두 참조함
- **이중 연결 구조**
    - 마지막에 데이터를 추가하는 경우에도 O(1) 성능 제공
    - 역방향 조회도 가능해서 인덱스 조회 성능 최적화 가능

---


## 섹션 8. 컬렉션 프레임워크 - HashSet



**해시 함수**

- 임의의 길이 데이터를 고정된 길이의 해시값(해시코드)로 변환하는 함수
- 같은 입력값 → 항상 같은 해시코드 출력
- 다른 입력값 → 같은 해시코드가 나올 수도 있음 (해시 충돌 발생 가능)

**해시 코드**

- 데이터를 대표하는 정수값임

**해시 인덱스**

- 해시 코드를 기반으로 데이터 저장 위치를 정하는 값임

**정리**

- 문자 데이터를 사용할 때도, 해시 함수로 정수 기반 해시코드로 바꾼 다음, 해시 인덱스를 사용해 저장함

---

### 자바의 `hashCode()`

- 모든 자바 객체는 `hashCode()` 메서드를 가지고 있음 (Object 클래스에서 상속)
- 보통 직접 만든 객체는 `hashCode()`를 재정의해서 사용함
- 기본 구현은 객체 참조값 기반이라 인스턴스가 다르면 해시 코드도 다름

**동일성과 동등성**

| 구분 | 의미 | 비교 방법 |
|------|------|-----------|
| 동일성 (identity) | 객체 참조가 같은지 확인 | `==` 연산자 |
| 동등성 (equality) | 논리적으로 같은지 확인 | `equals()` 메서드 |

**정리**

- 자바에서 제공하는 대부분의 클래스는 `hashCode()` 재정의되어 있음
- 직접 만든 객체도 해시 자료구조에 넣으려면 `hashCode()` 재정의해야 함
- `hashCode()`만 재정의해도 되지만, 보통 `equals()`도 함께 재정의함

---

**equals(), hashCode()의 중요성**

- 해시 인덱스 충돌이 일어날 수 있으므로, `hashCode()` 뿐 아니라 `equals()`도 꼭 재정의해야 함
- 충돌이 일어나면 같은 해시 인덱스에 저장된 객체들을 하나하나 비교해야 하는데, 이때 `equals()`가 사용됨

**Object 기본 기능 정리**

| 메서드 | 역할 |
|--------|------|
| `hashCode()` | 객체 참조값 기반 해시코드 반환 |
| `equals()` | `==` 기준으로 동일성 비교 |

---


**정리**

- 해시 자료구조를 쓰는 경우에만 `hashCode()`와 `equals()`를 꼭 같이 재정의하면 됨
- 항상 재정의할 필요는 없지만, Set이나 Map과 같은 해시 기반 자료구조를 쓸 때는 필수임

---

