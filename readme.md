
## 섹션 2. 제네릭 - Generic1

### 제네릭이란?

- 제네릭(Generic)을 사용하면 **코드 재사용**과 **타입 안전성**을 동시에 확보할 수 있음
- `< >`를 사용해 선언한 클래스를 **제네릭 클래스**라고 함
- 제네릭 클래스를 사용하면 `Integer`, `String` 등 구체적인 타입을 미리 지정하지 않아도 됨
- 클래스명 오른쪽에 `<T>`를 선언하면, `T`는 **타입 매개변수(type parameter)**가 됨
- 클래스 내부에서 `T value`와 같이 타입 매개변수를 사용하면, 실제 객체 생성 시 구체적인 타입으로 대체됨

- 제네릭을 사용하면, 클래스 내부에서 사용할 타입을 **정의 시점이 아닌 생성 시점**에 결정 가능

### 메서드 매개변수 vs 제네릭 타입 매개변수

| 구분 | 설명 |
|------|------|
| 메서드 매개변수 | 사용할 **값**에 대한 결정을 나중으로 미룸 |
| 제네릭 타입 매개변수 | 사용할 **타입**에 대한 결정을 나중으로 미룸 |

- 메서드는 **매개변수에 인자**를 전달해 값을 결정
- 제네릭 클래스는 **타입 매개변수에 타입 인자**를 전달해 사용할 타입을 결정

- 제네릭 용어와 관례도 학습함 (예: `T`, `E`, `K`, `V` 등의 관용적 타입 명칭)

---

## 섹션 3. 제네릭 - Generic2


### 타입 제한의 필요성

- 제네릭은 기본적으로 어떤 타입이든 허용함
- 타입 매개변수를 `Object`로 가정하고 사용할 경우, Object의 기능만 사용 가능

- 이 문제를 해결하기 위해 **상위 타입 제한**을 적용


### 타입 제한 적용

- `T extends Number`처럼 상한을 설정해 특정 타입군만 사용 가능
- 이렇게 하면, **타입 안정성**을 유지하면서도 **상위 타입의 기능**을 사용할 수 있음

- 코드 재사용성과 타입 안정성 모두 확보 가능

---


### 제네릭 메서드와 제네릭 클래스의 차이

- 제네릭 타입: 객체 **생성 시점**에 타입 인자 전달
- 제네릭 메서드: 메서드 **호출 시점**에 타입 인자 전달
- 제네릭 메서드는 클래스 전체가 아닌 **특정 메서드 단위**에만 제네릭 적용할 때 사용

| 구분 | 설명 |
|------|------|
| 정적(static) 메서드 | 제네릭 **메서드만** 적용 가능 |
| 인스턴스 메서드 | 제네릭 **타입, 메서드 모두** 적용 가능 |
| 우선순위 | 제네릭 메서드가 제네릭 타입보다 **우선 적용**됨 |

---

### 와일드카드 (`?`)

- `?`는 하나 이상의 타입을 포괄하는 **특수 문자**
- **제네릭 타입 또는 메서드를 선언할 때가 아니라**, 이미 정의된 제네릭을 활용할 때 사용
- 예를 들어, `List<?>`는 어떤 타입의 리스트든 받을 수 있음

#### 상한 와일드카드

- `? extends Type`: 특정 타입(Type) **하위 타입만 허용**

### 와일드카드 vs 제네릭 타입/메서드

- 와일드카드는 제네릭 타입 활용에 적합
- **타입이 꼭 필요하고, 메서드 내부에서 타입이 바뀌어야 한다면** 제네릭 타입 또는 제네릭 메서드를 사용하는 것이 적절

---

### 타입 이레이저 (Type Erasure)

- 제네릭은 **컴파일 시점**에만 존재
- 컴파일 이후에는 **타입 정보가 삭제됨**
- 런타임 시에는 모든 제네릭 타입이 **Object**로 처리됨

---


## 섹션 4. 컬렉션 프레임워크 - ArrayList

### 배열의 특징 1 - 배열과 인덱스

자료구조는 데이터를 구조화해서 다루는 방식이고 배열은 그 대표적인 예시

배열의 특징
- 인덱스를 통해 데이터 접근이 매우 빠름
- 입력, 변경, 조회는 인덱스를 이용해서 한 번의 계산으로 위치를 바로 찾을 수 있음
- 하지만 검색은 모든 요소를 하나씩 확인해야 해서 오래 걸림

### 빅오(Big-O) 표기법

알고리즘 성능을 수학적으로 표현한 방식임. 대표적인 시간 복잡도

| 표기법      | 의미                       | 설명                                              |
|-------------|----------------------------|---------------------------------------------------|
| O(1)        | 상수 시간                  | 입력 크기에 관계없이 실행 시간 일정               |
| O(n)        | 선형 시간                  | 입력 크기에 비례해 실행 시간 증가                 |
| O(n²)       | 제곱 시간                  | 입력 크기의 제곱에 비례해 실행 시간 증가          |
| O(log n)    | 로그 시간                  | 입력 크기의 로그에 비례해 실행 시간 증가          |
| O(n log n)  | 선형 로그 시간             | 대표적으로 병합 정렬에서 사용됨                   |

**배열 관련 시간 복잡도 정리**

| 작업            | 시간 복잡도 |
|-----------------|--------------|
| 인덱스 접근     | O(1)         |
| 순차 검색       | O(n)         |

### 배열의 특징 2 - 데이터 추가 시 성능 변화

배열에 데이터를 추가할 때 위치에 따라 성능이 달라짐

| 위치     | 설명                                                                 | 시간 복잡도 |
|----------|----------------------------------------------------------------------|--------------|
| 첫번째   | 첫 인덱스 접근 O(1) + 나머지 한 칸씩 밀기 O(n)                       | O(n)         |
| 중간     | 중간 인덱스 접근 O(1) + 오른쪽 데이터 평균 O(n/2) 밀기              | O(n)         |
| 마지막   | 이동 없이 바로 추가 가능                                             | O(1)         |

배열의 한계 
→ 크기를 고정해야 해서 유연하지 않음

### 직접 구현하는 배열 리스트 1 - 시작

기존 배열의 불편함

1. 길이 조절 불가
2. 데이터 추가가 번거로움

이런 문제를 해결하기 위해 **동적으로 크기를 조절할 수 있는 List 자료 구조**가 사용됨

**List**란: 순서가 있고, 중복 데이터를 허용하는 자료 구조임

### 직접 구현하는 배열 리스트 2~5 - 동적 배열 및 제네릭

제네릭으로 구현할 때 `Object[] elementData`를 그대로 사용하는 이유

- 제네릭은 런타임에 타입 정보가 사라짐(타입 소거), 그래서 생성자에서는 타입 매개변수를 사용할 수 없음
- 그래서 생성자 내부에서 배열을 만들 땐 `Object[]`를 써야 함
- 하지만 입력/반환은 제네릭 타입으로 제한되기 때문에 다운캐스팅 과정이 안전하게 보장됨

**MyArrayList 단점 요약**

- 정확한 크기를 예측하지 못하면 메모리를 낭비하게 됨
- 중간 삽입/삭제 시 성능이 떨어짐

정리  
→ 배열 리스트는 **마지막에 추가/삭제할 때는 효율적**이지만, **앞이나 중간 위치에서는 성능이 좋지 않음**

---

## 섹션 5. 컬렉션 프레임워크 - LinkedList

### 배열 리스트의 단점

배열 리스트는 내부에 **배열**을 사용해서 데이터를 저장하고 관리함  
문제는 배열 크기를 미리 확보해야 해서, 얼마나 데이터가 추가될지 모르는 경우 **남는 공간이 낭비**된다는 것

### 노드와 연결

배열의 단점을 보완하기 위해 **노드(Node)** 를 사용해서 데이터를 연결하는 방식이 나옴

- 낭비되는 메모리 없이 필요한 만큼만 메모리를 확보해서 사용함
- 앞이나 중간에 데이터를 추가, 삭제할 때 효율적임
- 새로운 노드를 만들고, 서로 연결해서 관리함

**노드 클래스 구조**

```java
public class Node {
    Object item;
    Node next;
}
```

- `item`: 저장할 데이터
- `next`: 다음 노드를 가리키는 참조

이런 구조를 기반으로 데이터를 연결하는 자료구조를 **연결 리스트(LinkedList)** 라고 부름

---

### 연결 리스트 vs 배열 리스트 성능 비교

중간에 있는 항목을 추가하거나 삭제할 때, 연결 리스트와 배열 리스트 모두 시간 복잡도는 O(n)임  
하지만 상황에 따라 둘 중 더 나은 선택이 있음.

| 기능         | 배열 리스트 (ArrayList) | 연결 리스트 (LinkedList) |
|--------------|--------------------------|---------------------|
| 인덱스 조회   | O(1) (빠름)               | O(n) (느림)           |
| 검색         | O(n)                      | O(n)                |
| 앞에 추가    | O(n) (모두 이동해야 함)    | O(1) (노드만 연결)       |
| 뒤에 추가    | O(1)                      | O(n)                |
| 평균 위치 추가 | O(n)                    | O(n)                |

정리하면:

- **조회가 많고, 뒤쪽에 데이터 추가가 많을 때** → 배열 리스트가 성능이 더 좋음
- **앞쪽 데이터 추가/삭제가 많을 때** → 연결 리스트가 성능이 더 좋음

---

### 제네릭 도입

연결 리스트에 제네릭을 적용해서 타입을 고정할 수 있게 했음  
덕분에 여러 타입의 데이터를 안전하게 다룰 수 있음

---

